package Schwager.src.ch.fhnw.efalg.algorithm; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.Observable; import java.util.PriorityQueue; import java.util.function.Predicate; import Schwager.src.ch.fhnw.efalg.Nonogram; import Schwager.src.ch.fhnw.efalg.NonogramStarter; import Schwager.src.ch.fhnw.efalg.NonogramValues; class NonogramSolver extends Observable { Nonogram VARIABLE_NAME; PriorityQueue<NonogramValues> VARIABLE_NAME; PriorityQueue<NonogramValues> VARIABLE_NAME; NonogramSolver(Nonogram VARIABLE_NAME) { this.VARIABLE_NAME = VARIABLE_NAME; } void startSolving() { VARIABLE_NAME = new PriorityQueue<NonogramValues>(VARIABLE_NAME.getValuesX().length, Collections.reverseOrder()); for (NonogramValues u : VARIABLE_NAME.getValuesX()) VARIABLE_NAME.add(u); VARIABLE_NAME = new PriorityQueue<NonogramValues>(VARIABLE_NAME.getValuesY().length, Collections.reverseOrder()); for (NonogramValues v : VARIABLE_NAME.getValuesY()) VARIABLE_NAME.add(v); fillEmptyValues(VARIABLE_NAME.getField(), VARIABLE_NAME); fillEmptyValues(VARIABLE_NAME.getField(), VARIABLE_NAME); fillFixedValues(VARIABLE_NAME.getField()); if (!solved()) trySolvePermutation(VARIABLE_NAME.getField()); if(NonogramStarter.UPDATE_CHANGES) { setChanged(); notifyObservers(); } } void fillFixedValues(int[][] board) { while (fillFixedValues(VARIABLE_NAME.getField(), VARIABLE_NAME, e -> VARIABLE_NAME.size() - e.getSize() < 15) | fillFixedValues(VARIABLE_NAME.getField(), VARIABLE_NAME, e -> VARIABLE_NAME.size() - e.getSize() < 15)) { if(NonogramStarter.UPDATE_CHANGES) { setChanged(); notifyObservers(); } } while (fillFixedValues(VARIABLE_NAME.getField(), VARIABLE_NAME, e -> VARIABLE_NAME.size() - e.getSize() < 25) | fillFixedValues(VARIABLE_NAME.getField(), VARIABLE_NAME, e -> VARIABLE_NAME.size() - e.getSize() < 25)) { if(NonogramStarter.UPDATE_CHANGES) { setChanged(); notifyObservers(); } } while (fillFixedValues(VARIABLE_NAME.getField(), VARIABLE_NAME, e -> getConnectedUndefinedFields(getRowFromBoard(board, e)) - e.getSize() < 5) | fillFixedValues(VARIABLE_NAME.getField(), VARIABLE_NAME, e -> getConnectedUndefinedFields(getRowFromBoard(board, e)) - e.getSize() < 5)) { if(NonogramStarter.UPDATE_CHANGES) { setChanged(); notifyObservers(); } } } int getConnectedUndefinedFields(int[] rowFromBoard) { int VARIABLE_NAME = 0; int count = 0; for (int i = 0; i < rowFromBoard.length; i++) { if (rowFromBoard[i] == 0) count++; else { if (count > VARIABLE_NAME) VARIABLE_NAME = count; count = 0; } } return VARIABLE_NAME; } void fillEmptyValues(int[][] board, Collection<NonogramValues> values) { values.parallelStream().filter(e -> e.getValues().length == 0).forEach(e -> { setRowFromBoard(board, e, -1); }); } boolean fillFixedValues(int[][] board, Collection<NonogramValues> values, Predicate<NonogramValues> filter) { return values.parallelStream().filter(filter).map(e -> { int[] currentRow = getRowFromBoard(board, e); int[] newRow = e.getFixedFields(currentRow); if (setRowFromBoard(board, e, newRow)) return true; return false; }).reduce(false, (a, b) -> a || b); } int[] getRowFromBoard(int[][] board, NonogramValues e) { if (!e.isXAxis()) return board[e.getIndex()]; int[] copy = new int[board.length]; for (int i = 0; i < copy.length; i++) copy[i] = board[i][e.getIndex()]; return copy; } void setRowFromBoard(int[][] board, NonogramValues e, int value) { if (e.isXAxis()) { for (int i = 0; i < board.length; i++) { board[i][e.getIndex()] = value; } } else { for (int i = 0; i < board[e.getIndex()].length; i++) { board[e.getIndex()][i] = value; } } } boolean setRowFromBoard(int[][] board, NonogramValues e, int[] row) { boolean solutionFound = false; if (e.isXAxis()) { for (int i = 0; i < row.length; i++) { if (row[i] != board[i][e.getIndex()]) { solutionFound = true; board[i][e.getIndex()] = row[i]; } } } else { for (int i = 0; i < row.length; i++) { if (row[i] != board[e.getIndex()][i]) { solutionFound = true; board[e.getIndex()][i] = row[i]; } } } return solutionFound; } boolean trySolvePermutation(int[][] board) { int[][] boardCopy = new int[VARIABLE_NAME.getValuesY().length][VARIABLE_NAME.getValuesX().length]; copyBoard(board, boardCopy); NonogramValues v = VARIABLE_NAME.poll(); int[] spacesBetween = Arrays.copyOf(v.getStartSpaces(), v.getStartSpaces().length); int[] permutation = new int[board.length]; int[] boardRow = getRowFromBoard(board, v); do { if (v.createValidPermutation(boardRow, permutation, spacesBetween)) { setRowFromBoard(board, v, permutation); if(NonogramStarter.UPDATE_CHANGES) { setChanged(); notifyObservers(); } try { fillFixedValues(board); if (solved()) return true; else if (trySolvePermutation(board)) return true; } catch (NullPointerException ex) { } copyBoard(boardCopy, board); } } while (v.nextSpacesBetween(board.length, spacesBetween)); VARIABLE_NAME.offer(v); return false; } boolean solved() { for (int i = 0; i < VARIABLE_NAME.getField().length; i++) for (int j = 0; j < VARIABLE_NAME.getField()[i].length; j++) if (VARIABLE_NAME.getField()[i][j] == 0) return false; return true; } void copyBoard(int[][] from, int[][] to) { for (int i = 0; i < from.length; i++) to[i] = Arrays.copyOf(from[i], from[i].length); } } package Schwager.src.ch.fhnw.efalg.algorithm.old.cachingtest; import java.util.Observable; class NonogramSolver extends Observable { } package Schwager.src.ch.fhnw.efalg.algorithm.old.cachingtest; import java.util.ArrayList; import java.util.List; import java.util.stream.Collectors; import java.util.stream.Stream; class NonogramValues implements Comparable<NonogramValues> { int[] values; int size; int index; boolean xAxis; List<int[]> permutationCache; NonogramValues(int[] values, int index, boolean xAxis) { super(); this.values = values; for(int val : values) { this.size += val; } this.size += values.length-1; this.index = index; this.xAxis = xAxis; } int[] getValues() { return values; } @Override int compareTo(NonogramValues val) { return size - val.size; } List<int[]> getPermutations() { return permutationCache; } List<int[]> createPermutations(int fieldSize) { List<int[]> permutations = new ArrayList<int[]>(); int[] whitespaces = new int[values.length+1]; for(int x = 1; x < whitespaces.length-1; x++) whitespaces[x] = 1; whitespaces[0] = 0; whitespaces[whitespaces.length-1] = fieldSize-size; permutations.add(whitespacesToPermutation(fieldSize, whitespaces)); while(nextWhitespace(fieldSize, whitespaces)) { permutations.add(whitespacesToPermutation(fieldSize, whitespaces)); } return permutations; } boolean nextWhitespace(int fieldSize, int[] whitespaces) { if(whitespaces[0] == fieldSize - size) return false; if(whitespaces[whitespaces.length-1] > 0) { whitespaces[whitespaces.length-1]--; whitespaces[whitespaces.length-2]++; return true; } int i = whitespaces.length-2; while(i > 0) { if(whitespaces[i] == 1) { i--; } else { whitespaces[whitespaces.length-1] = whitespaces[i] - 2; whitespaces[i-1]++; whitespaces[i] = 1; return true; } } return false; } int[] whitespacesToPermutation(int fieldSize, int[] whitespaces) { int[] permutation = new int[fieldSize]; int valIndex = 0; int whiIndex = 0; int count = 0; for(int x = 0; x < fieldSize; x++) { if(valIndex == whiIndex) { if(whitespaces[whiIndex] == count) { count = 0; permutation[x] = 1; whiIndex++; } else { permutation[x] = -1; } } else { if(values[valIndex] == count) { count = 0; permutation[x] = -1; valIndex++; } else { permutation[x] = 1; } } count++; } return permutation; } Stream<int[]> filterPermutations(int[][] board, boolean caching) { List<int[]> permutations; if(permutationCache != null) { permutations = permutationCache; } else { if(xAxis) permutations = createPermutations(board.length); else permutations = createPermutations(board[0].length); } Stream<int[]> stillPossiblePermutations = permutations.stream().filter(e -> { for(int i = 0; i < e.length; i++) if(xAxis && board[i][index] + e[i] == 0) return false; else if(!xAxis && board[index][i] + e[i] == 0) return false; return true; }); if(!caching) return stillPossiblePermutations; permutationCache = stillPossiblePermutations.collect(Collectors.toList()); return permutationCache.stream(); } int getIndex() { return index; } boolean isXAxis() { return xAxis; } } package Schwager.src.ch.fhnw.efalg.console; import java.util.Observable; import java.util.Observer; import Schwager.src.ch.fhnw.efalg.Nonogram; class NonogramConsole implements Observer { Nonogram VARIABLE_NAME; NonogramConsole(Nonogram VARIABLE_NAME) { this.VARIABLE_NAME = VARIABLE_NAME; printNonogram(); } @Override void update(Observable o, Object arg) { printNonogram(); } void printNonogram() { System.out.println(); System.out.println(); System.out.println(); int[][] field = VARIABLE_NAME.getField(); for(int j = 0; j < VARIABLE_NAME.getValuesY().length; j++) { for(int i = 0; i < VARIABLE_NAME.getValuesX().length; i++) { if(field[j][i] == 1) System.out.print(); else if(field[j][i] == 0) System.out.print(); else System.out.print(); } System.out.println(); } } } package Schwager.src.ch.fhnw.efalg.gui; import java.awt.Color; import java.awt.Graphics; import javax.swing.JPanel; import Schwager.src.ch.fhnw.efalg.Nonogram; class NonogramDrawPanel extends JPanel { Nonogram VARIABLE_NAME; NonogramDrawPanel(Nonogram VARIABLE_NAME) { this.VARIABLE_NAME = VARIABLE_NAME; } @Override void paintComponent(Graphics g) { super.paintComponent(g); double scalingX = getWidth()/VARIABLE_NAME.getValuesX().length; double scalingY = getHeight()/VARIABLE_NAME.getValuesY().length; int[][] field = VARIABLE_NAME.getField(); for(int i = 0; i < field.length; i++) { for(int j = 0; j < field[i].length; j++) { if(field[i][j] == 1) g.setColor(Color.black); else if(field[i][j] == 0) g.setColor(Color.gray); else g.setColor(Color.white); g.fillRect((int)(j*scalingX), (int)(i*scalingY), (int)((j+1)*scalingX), (int)((i+1)*scalingY)); g.setColor(Color.white); g.drawRect((int)(j*scalingX), (int)(i*scalingY), (int)((j+1)*scalingX), (int)((i+1)*scalingY)); } } } } package Schwager.src.ch.fhnw.efalg.gui; import java.awt.BorderLayout; import java.util.Observable; import java.util.Observer; import javax.swing.JFrame; import javax.swing.SwingUtilities; import Schwager.src.ch.fhnw.efalg.Nonogram; class NonogramGui extends JFrame implements Observer { static int WIDTH = 600; static int HEIGHT = 400; NonogramGui(Nonogram VARIABLE_NAME) { setSize(WIDTH, HEIGHT); add(new NonogramDrawPanel(VARIABLE_NAME), BorderLayout.CENTER); setVisible(true); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); } @Override void update(Observable o, Object arg) { SwingUtilities.invokeLater(() -> repaint()); } } package Schwager.src.ch.fhnw.efalg; class Nonogram { NonogramValues[] valuesX; NonogramValues[] valuesY; int[][] currentField; Nonogram(NonogramValues[] valuesX, NonogramValues[] valuesY) { super(); this.valuesX = valuesX; this.valuesY = valuesY; this.currentField = new int[valuesY.length][valuesX.length]; } NonogramValues[] getValuesX() { return valuesX; } NonogramValues[] getValuesY() { return valuesY; } int[][] getField() { return currentField; } } package Schwager.src.ch.fhnw.efalg; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStreamReader; import java.util.Observer; import javax.swing.JFileChooser; import javax.swing.SwingUtilities; import Schwager.src.ch.fhnw.efalg.algorithm.NonogramSolver; import Schwager.src.ch.fhnw.efalg.console.NonogramConsole; import Schwager.src.ch.fhnw.efalg.gui.NonogramGui; class NonogramStarter { static boolean UPDATE_CHANGES = true; static boolean USE_GUI = true; static Observer outputChannel; static void main(String[] args) { try { JFileChooser filechooser = new JFileChooser(new File()); filechooser.setDialogTitle(); filechooser.setMultiSelectionEnabled(false); if (filechooser.showOpenDialog(null) != JFileChooser.APPROVE_OPTION) return; Nonogram VARIABLE_NAME = readNonogramFromFile(filechooser.getSelectedFile()); NonogramSolver s = new NonogramSolver(VARIABLE_NAME); if (USE_GUI) SwingUtilities.invokeLater(() -> { outputChannel = new NonogramGui(VARIABLE_NAME); s.addObserver(outputChannel); }); else { outputChannel = new NonogramConsole(VARIABLE_NAME); s.addObserver(outputChannel); } s.startSolving(); } catch (IOException | NumberFormatException ex) { return; } } static Nonogram readNonogramFromFile(File f) throws IOException { try (BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(f)))) { String[] lengths = br.readLine().split(); if (lengths.length < 2) throw new IOException(); int yLength = Integer.parseInt(lengths[0]); int xLength = Integer.parseInt(lengths[1]); NonogramValues[] xValues = new NonogramValues[xLength]; NonogramValues[] yValues = new NonogramValues[yLength]; int currentLine = 0; while (currentLine != yLength) { String[] values = br.readLine().trim().split(); yValues[currentLine] = getNonogramValuesFromString(values, xLength, currentLine, false); currentLine++; } currentLine = 0; while (currentLine != xLength) { String[] values = br.readLine().trim().split(); xValues[currentLine] = getNonogramValuesFromString(values, yLength, currentLine, true); currentLine++; } return new Nonogram(xValues, yValues); } } static NonogramValues getNonogramValuesFromString(String[] values, int fieldSize, int index, boolean xAxis) { int[] nonogramValues = new int[values.length]; if (values.length == 1 && .equals(values[0])) nonogramValues = new int[0]; for (int i = 0; i < nonogramValues.length; i++) { nonogramValues[i] = Integer.parseInt(values[i]); } return new NonogramValues(nonogramValues, fieldSize, index, xAxis); } } package Schwager.src.ch.fhnw.efalg; import java.util.Arrays; class NonogramValues implements Comparable<NonogramValues> { int[] values; int index; boolean xAxis; int[] startSpaces; int size; NonogramValues(int[] values, int fieldSize, int index, boolean xAxis) { super(); this.values = values; for (int val : values) { this.size += val; } this.size += values.length - 1; this.index = index; this.xAxis = xAxis; if (values.length == 0) startSpaces = new int[1]; else startSpaces = new int[values.length + 1]; for (int x = 1; x < startSpaces.length - 1; x++) startSpaces[x] = 1; startSpaces[0] = 0; startSpaces[startSpaces.length - 1] = fieldSize - size; } int[] getValues() { return values; } int getIndex() { return index; } boolean isXAxis() { return xAxis; } int getSize() { return size; } int[] getStartSpaces() { return startSpaces; } @Override int compareTo(NonogramValues val) { if (size - val.size == 0) return index - val.getIndex(); return size - val.size; } boolean nextSpacesBetween(int fieldSize, int[] spacesBetween) { if (spacesBetween[0] == fieldSize - size) return false; if (spacesBetween[spacesBetween.length - 1] > 0) { spacesBetween[spacesBetween.length - 1]--; spacesBetween[spacesBetween.length - 2]++; return true; } int i = spacesBetween.length - 2; while (i > 0) { if (spacesBetween[i] == 1) { i--; } else { spacesBetween[spacesBetween.length - 1] = spacesBetween[i] - 2; spacesBetween[i - 1]++; spacesBetween[i] = 1; return true; } } return false; } int[] getFixedFields(int[] currentBoardRow) { int[] newBoardRow = null; int[] spacesBetween = Arrays.copyOf(startSpaces, startSpaces.length); int[] permutation = new int[currentBoardRow.length]; do { if (createValidPermutation(currentBoardRow, permutation, spacesBetween)) { if (newBoardRow == null) { newBoardRow = Arrays.copyOf(permutation, permutation.length); } else { for (int i = 0; i < permutation.length; i++) if (newBoardRow[i] + permutation[i] == 0) newBoardRow[i] = 0; } } } while (nextSpacesBetween(permutation.length, spacesBetween)); return newBoardRow; } boolean METHOD_NAME(int[] currentBoardRow, int[] permutation, int[] spacesBetween) { int valIndex = 0; int whiIndex = 0; int count = 0; for (int i = 0; i < permutation.length; i++) { if (valIndex == whiIndex) { if (spacesBetween[whiIndex] == count) { if (currentBoardRow[i] == -1) return false; count = 0; permutation[i] = 1; whiIndex++; } else { if (currentBoardRow[i] == 1) return false; permutation[i] = -1; } } else { if (values[valIndex] == count) { if (currentBoardRow[i] == 1) return false; count = 0; permutation[i] = -1; valIndex++; } else { if (currentBoardRow[i] == -1) return false; permutation[i] = 1; } } count++; } return true; } } 