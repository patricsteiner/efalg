import java.io.InputStream; import java.util.*; import java.util.stream.Collectors; class Nonogram { int VARIABLE_NAME, width; int[][] VARIABLE_NAME; int[][] VARIABLE_NAME; int[][] VARIABLE_NAME; List<List<Integer>> VARIABLE_NAME; List<List<Integer>> VARIABLE_NAME; int VARIABLE_NAME = 0; boolean stopped; int rowCounter = 0; static int UNKNOWN = 0; static int FILLED = 1; static int EMPTY = -1; int getHeight() { return VARIABLE_NAME; } int getWidth() { return width; } List<List<Integer>> getRowHints() { return VARIABLE_NAME; } List<List<Integer>> getColHints() { return VARIABLE_NAME; } int get(int i, int j) { return VARIABLE_NAME[i][j]; } int getPrediction(int i, int j) { return VARIABLE_NAME[i][j]; } int getPreprocessed(int i, int j) { return VARIABLE_NAME[i][j]; } Nonogram(InputStream in) { Scanner scanner = new Scanner(in); VARIABLE_NAME = scanner.nextInt(); width = scanner.nextInt(); scanner.nextLine(); VARIABLE_NAME = new ArrayList<>(VARIABLE_NAME); VARIABLE_NAME = new ArrayList<>(width); List<List<Integer>> listToAddThings = VARIABLE_NAME; for (int i = 0; i < VARIABLE_NAME + width; i++) { if (i >= VARIABLE_NAME) listToAddThings = VARIABLE_NAME; listToAddThings.add(Arrays.stream(scanner.nextLine().split()).mapToInt(Integer::parseInt).boxed().collect(Collectors.toList())); } scanner.close(); VARIABLE_NAME = new int[VARIABLE_NAME][]; VARIABLE_NAME = new int[VARIABLE_NAME][]; VARIABLE_NAME = new int[VARIABLE_NAME][]; for (int i = 0; i < VARIABLE_NAME; i++) { VARIABLE_NAME[i] = new int[width]; VARIABLE_NAME[i] = new int[width]; VARIABLE_NAME[i] = new int[width]; } } boolean solve(int VARIABLE_NAME) throws InterruptedException { stopped = false; this.VARIABLE_NAME = VARIABLE_NAME; preprocess(); return findSolution(0); } void stopSolving() { stopped = true; } void firstPermutation(int i) { int j = 0; for (int hint : VARIABLE_NAME.get(i)) { for (int k = 0; k < hint; k++) { VARIABLE_NAME[i][j++] = FILLED; } if (j < width) VARIABLE_NAME[i][j++] = EMPTY; } while (j < width) VARIABLE_NAME[i][j++] = EMPTY; } void firstPermutationWithPredictions(int row) { firstPermutation(row); int firstBlockSize = VARIABLE_NAME.get(row).get(0); if (firstBlockSize == 0 || VARIABLE_NAME.get(row).size() < 2) return; if (VARIABLE_NAME[row][0] == FILLED) return; int sumOfAllBlocksButFirst = 0; for (int x = 1; x < VARIABLE_NAME.get(row).size(); x++) { sumOfAllBlocksButFirst += VARIABLE_NAME.get(row).get(x); } int filled = 0; int p = width - 1; while (filled <= sumOfAllBlocksButFirst) { if (VARIABLE_NAME[row][p] == FILLED) filled++; if (--p < 0) return; } p++; int shift = p - firstBlockSize + 1; if (shift < 1) return; for (int j = width - 1; j > p; j--) { VARIABLE_NAME[row][j] = VARIABLE_NAME[row][j - shift]; VARIABLE_NAME[row][j - shift] = EMPTY; } } void resetRow(int i) { for (int j = 0; j < width; j++) { VARIABLE_NAME[i][j] = UNKNOWN; VARIABLE_NAME[i][j] = UNKNOWN; } } void preprocess() { for (int i = 0; i < VARIABLE_NAME; i++) { int sumOfHints = VARIABLE_NAME.get(i).stream().mapToInt(Integer::valueOf).sum(); int minimalOccupiedSpace = sumOfHints + VARIABLE_NAME.get(i).size() - 1; int pos = 0; for (int k = 0; k < VARIABLE_NAME.get(i).size(); k++) { pos = pos + VARIABLE_NAME.get(i).get(k) - 1; int difference = width - minimalOccupiedSpace - VARIABLE_NAME.get(i).get(k); if (difference < 0) { for (int j = pos; j > pos + difference; j--) { VARIABLE_NAME[i][j] = FILLED; } } pos += 2; } } for (int j = 0; j < width; j++) { int sumOfHints = VARIABLE_NAME.get(j).stream().mapToInt(Integer::valueOf).sum(); int minimalOccupiedSpace = sumOfHints + VARIABLE_NAME.get(j).size() - 1; int pos = 0; for (int k = 0; k < VARIABLE_NAME.get(j).size(); k++) { pos = pos + VARIABLE_NAME.get(j).get(k) - 1; int difference = VARIABLE_NAME - minimalOccupiedSpace - VARIABLE_NAME.get(j).get(k); if (difference < 0) { for (int i = pos; i > pos + difference; i--) { VARIABLE_NAME[i][j] = FILLED; } } pos += 2; } } } boolean findSolution(int row) throws InterruptedException { if (stopped) return true; if (rowCounter++ == VARIABLE_NAME) { System.out.println(); System.out.println(this); return true; } makePrediction(row); while (nextPermutation(row)) { if (VARIABLE_NAME > 0) Thread.sleep(VARIABLE_NAME); if (matchesPrediction(row) && matchesPreprocessed(row)) { if (findSolution(row + 1)) return true; } } resetRow(row); rowCounter--; return false; } void makePrediction(int row) { if (row == 0) return; for (int j = 0; j < width; j++) { Iterator<Integer> hints = VARIABLE_NAME.get(j).iterator(); int blockSize = 0; int hint = hints.next(); for (int i = 0; i < row; i++) { if (VARIABLE_NAME[i][j] == FILLED || VARIABLE_NAME[i][j] == FILLED) { blockSize++; } else if (VARIABLE_NAME[i][j] == EMPTY || VARIABLE_NAME[i][j] == EMPTY) { if (blockSize > 0) hint = hints.hasNext() ? hints.next() : 0; blockSize = 0; } } if (blockSize > 0 && blockSize < hint) { VARIABLE_NAME[row][j] = FILLED; } else if (blockSize == hint) { VARIABLE_NAME[row][j] = EMPTY; } else { VARIABLE_NAME[row][j] = UNKNOWN; } } } boolean matchesPrediction(int row) { for (int j = 0; j < width; j++) { if (VARIABLE_NAME[row][j] != UNKNOWN && VARIABLE_NAME[row][j] != VARIABLE_NAME[row][j]) { return false; } } return true; } boolean matchesPreprocessed(int row) { for (int j = 0; j < width; j++) { if (VARIABLE_NAME[row][j] != UNKNOWN && VARIABLE_NAME[row][j] != VARIABLE_NAME[row][j]) { return false; } } return true; } boolean nextPermutation(int row) { int rightMostBlockSize = VARIABLE_NAME.get(row).get(VARIABLE_NAME.get(row).size() - 1); if (rightMostBlockSize == 0) return false; int[] vector = VARIABLE_NAME[row]; if (vector[0] == UNKNOWN) { firstPermutationWithPredictions(row); return true; } int rightMostBlockPosition = vector.length - 1; while (vector[rightMostBlockPosition] == EMPTY && rightMostBlockPosition > 0) { rightMostBlockPosition--; } rightMostBlockPosition -= rightMostBlockSize - 1; if (rightMostBlockPosition + rightMostBlockSize < vector.length) { vector[rightMostBlockPosition] = EMPTY; vector[rightMostBlockPosition + rightMostBlockSize] = FILLED; return true; } int i = rightMostBlockPosition - 2; if (i < 0) return false; int emptyCells = 1; while(vector[i] == EMPTY || vector[i+1] != EMPTY || vector[i+2] != EMPTY) { if (vector[i] == EMPTY) emptyCells++; else emptyCells = 0; i--; if (i < 0) return false; } if (emptyCells < 1) return false; int filledCells = 1; while (i > 0 && vector[i-1] == FILLED) { filledCells++; i--; } vector[i] = EMPTY; vector[i + filledCells] = FILLED; for (int j = i + filledCells + 2; j < vector.length - emptyCells + 2; j++) { if (j != j + emptyCells - 2) { vector[j] = vector[j + emptyCells - 2]; vector[j + emptyCells - 2] = EMPTY; } } return true; } @Override String toString() { StringBuilder sb = new StringBuilder(); for (int[] row : VARIABLE_NAME) { for (int i : row) sb.append(i == UNKNOWN ? : i == EMPTY ? : ); sb.append(); } return sb.toString(); } }import javafx.animation.KeyFrame; import javafx.animation.Timeline; import javafx.application.Application; import javafx.concurrent.Task; import javafx.scene.Scene; import javafx.scene.control.Alert; import javafx.scene.control.Alert.AlertType; import javafx.stage.Stage; import javafx.util.Duration; import java.io.File; import java.io.FileInputStream; import java.io.PrintWriter; class NonoMain extends Application { static String FILENAME_IN = ; static String FILENAME_OUT = ; static int GUI_UPDATE_INTERVAL = 100; static boolean DEBUG_COLORS = true; static int DELAY = 0; Nonogram nonogram; int start; static void main(String[] args) { launch(args); } @Override void start(Stage primaryStage) throws Exception { nonogram = new Nonogram(new FileInputStream(new File(FILENAME_IN))); NonoPane nonoPane = new NonoPane(nonogram); nonoPane.setPrefWidth(700); nonoPane.setPrefHeight(700); Scene s = new Scene(nonoPane); primaryStage.setScene(s); nonoPane.setVisible(true); primaryStage.show(); Task<Boolean> solverTask = new Task<Boolean>() { @Override Boolean call() throws Exception { start = System.nanoTime(); return nonogram.solve(DELAY); } }; solverTask.setOnSucceeded(e -> { String elapsedTime = (System.nanoTime() - start)/1000000 + ; nonoPane.draw(); if (solverTask.getValue()) { new Alert(AlertType.INFORMATION, + elapsedTime).showAndWait(); try { PrintWriter p; p = new PrintWriter(new File(FILENAME_OUT)); p.print(nonogram.toString()); p.flush(); p.close(); } catch (Exception ex) { ex.printStackTrace(); } } else { new Alert(AlertType.ERROR, + elapsedTime + ).showAndWait(); } }); solverTask.setOnFailed(e -> System.err.println()); new Thread(solverTask).start(); Timeline guiUpdater = new Timeline(new KeyFrame(Duration.millis(GUI_UPDATE_INTERVAL), e -> nonoPane.draw())); guiUpdater.setCycleCount(Timeline.INDEFINITE); guiUpdater.play(); } @Override void stop() throws Exception { nonogram.stopSolving(); System.out.println(nonogram); super.stop(); } } import javafx.geometry.VPos; import javafx.scene.canvas.Canvas; import javafx.scene.canvas.GraphicsContext; import javafx.scene.layout.BorderPane; import javafx.scene.paint.Color; import javafx.scene.text.Font; import javafx.scene.text.TextAlignment; class NonoPane extends BorderPane { Nonogram nonogram; int gridWidth; int gridHeight; Canvas canvas; NonoPane(Nonogram nonogram) { canvas = new Canvas(); setCenter(canvas); canvas.widthProperty().bind(widthProperty()); canvas.heightProperty().bind(heightProperty()); widthProperty().addListener(e -> draw()); heightProperty().addListener(e -> draw()); setNonogram(nonogram); } void setNonogram(Nonogram nonogram) { this.nonogram = nonogram; gridHeight = nonogram.getHeight() + nonogram.getColHints().stream().max((l1, l2) -> l1.size() - l2.size()).get().size(); gridWidth = nonogram.getWidth() + nonogram.getRowHints().stream().max((l1, l2) -> l1.size() - l2.size()).get().size(); draw(); } double scaleX(double x) { return getWidth() / gridWidth * x; } double scaleY(double y) { return getHeight() / gridHeight * y; } void draw() { GraphicsContext gc = canvas.getGraphicsContext2D(); gc.setFill(Color.WHITE); gc.fillRect(0, 0, getWidth(), getHeight()); gc.setFill(Color.BLACK); gc.setTextAlign(TextAlignment.CENTER); gc.setTextBaseline(VPos.CENTER); gc.setFont(new Font(, getWidth() >= getHeight() ? scaleY(1) : scaleX(.8))); for (int i = 0; i < nonogram.getColHints().size(); i++) { int hints = nonogram.getColHints().get(i).size(); for (int j = 0; j < hints; j++) { double x = i + gridWidth - nonogram.getWidth() + .5; double y = gridHeight - nonogram.getHeight() - j - .5; gc.fillText(nonogram.getColHints().get(i).get(hints - j - 1).toString(), scaleX(x), scaleY(y)); } } for (int i = 0; i < nonogram.getRowHints().size(); i++) { int hints = nonogram.getRowHints().get(i).size(); for (int j = 0; j < hints; j++) { double x = gridWidth - nonogram.getWidth() - j - 1 + .5; double y = i + gridHeight - nonogram.getHeight() + 1 - .5; gc.fillText(nonogram.getRowHints().get(i).get(hints - j - 1).toString(), scaleX(x), scaleY(y)); } } for (int i = 0; i < nonogram.getHeight(); i++) { for (int j = 0; j < nonogram.getWidth(); j++) { Color color = Color.LIGHTGRAY; if (nonogram.get(i, j) == Nonogram.FILLED) color = Color.BLACK; else if (nonogram.get(i, j) == Nonogram.EMPTY) color = Color.DARKORCHID; if (nonogram.getPrediction(i, j) == Nonogram.FILLED) color = NonoMain.DEBUG_COLORS ? Color.GRAY : Color.BLACK; else if (nonogram.getPrediction(i, j) == Nonogram.EMPTY) color = NonoMain.DEBUG_COLORS ? Color.ORCHID : Color.DARKORCHID; if (nonogram.getPreprocessed(i, j) == Nonogram.FILLED) color = NonoMain.DEBUG_COLORS ? Color.DARKRED : Color.BLACK; gc.setFill(color); double x = j + gridWidth - nonogram.getWidth(); double y = i + gridHeight - nonogram.getHeight(); gc.fillRect(scaleX(x), scaleY(y), scaleX(x+1), scaleY(y+1)); } } gc.setStroke(Color.BLACK); gc.setLineWidth(1); for (int i = gridHeight - nonogram.getHeight(); i < gridHeight; i++) { gc.strokeLine(0, scaleY(i), scaleX(gridWidth), scaleY(i)); } for (int j = gridWidth - nonogram.getWidth(); j < gridWidth; j++) { gc.strokeLine(scaleX(j), 0, scaleX(j), METHOD_NAME(gridHeight)); } } } 