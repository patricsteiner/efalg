package ch.fhnw.M15_649_411.efalg.nonogram.algorithms; import ch.fhnw.M15_649_411.efalg.nonogram.NonoBoard; import javafx.application.Platform; import javafx.scene.control.Alert; import java.util.Date; abstract class AbstractAlgorithm { NonoBoard VARIABLE_NAME; Thread VARIABLE_NAME; AbstractAlgorithm(NonoBoard VARIABLE_NAME) { this.VARIABLE_NAME = VARIABLE_NAME; this.VARIABLE_NAME = new Thread(() -> { Date VARIABLE_NAME = new Date(System.currentTimeMillis()); System.out.println( + VARIABLE_NAME); execute(); Date end = new Date(System.currentTimeMillis()); System.out.println( + end); if (!isSolution()) { Platform.runLater(() -> { Alert alert = new Alert(Alert.AlertType.WARNING, ); alert.showAndWait(); }); } System.out.println( + ((end.getTime() - VARIABLE_NAME.getTime())) + ); }); } void VARIABLE_NAME() { VARIABLE_NAME.VARIABLE_NAME(); } void stop() { VARIABLE_NAME.stop(); Platform.runLater(() -> { Alert alert = new Alert(Alert.AlertType.WARNING, ); alert.showAndWait(); }); } boolean isRunning() { return VARIABLE_NAME.isAlive(); } abstract void execute(); abstract boolean isSolution(); } package ch.fhnw.M15_649_411.efalg.nonogram.algorithms.zx_algorithm; import ch.fhnw.M15_649_411.efalg.nonogram.NonoBoard; import java.util.Arrays; class Line { enum Layout { ROW, COLUMN } static double H_VEC_LEBGTH_EXP = 2; Layout layout; int index; int length; int[] vectors; double prio; int placedWhite, placedBlack; int vecSum; boolean mod; Line(Layout layout, int index, int length, int[] vectors) { this.layout = layout; this.index = index; this.length = length; this.vectors = vectors; this.vecSum = Arrays.stream(vectors).sum(); } void setPlaced(NonoBoard.State oldState, NonoBoard.State newState) { if(newState == NonoBoard.State.BLACK) { placedBlack++; } else { placedWhite++; } this.mod = true; } boolean isComplete() { return getPlaced() == length; } int getPlaced() { return placedWhite + placedBlack; } int getPlacedBlack() { return placedBlack; } int getPlacedWhite() { return placedWhite; } double getPrio() { if (mod) { this.prio = heuristic(); mod = false; } return prio; } double heuristic() { return ((length - getPlaced())) * (1. / ((vecSum / (double)vectors.length))) * ((vecSum - placedBlack)) * (Math.pow(vectors.length, H_VEC_LEBGTH_EXP)); } boolean isModPrio() { return mod; } @Override String toString() { return layout + + index; } } package ch.fhnw.M15_649_411.efalg.nonogram.algorithms.zx_algorithm; import java.util.Arrays; import ch.fhnw.M15_649_411.efalg.nonogram.NonoBoard.State; class Permutation { static int OK = 0; static int ABORT = -1; static int NEXT = 1; class Try { int code; Object o; Try(int code, Object o) { this.code = code; this.o = o; } } class Vectors { int[] v; int sum; int length; Vectors(int[] vectors, int lineLength) { this.v = new int[vectors.length * 2 + 1]; int vecSum = 0; for (int i = 0; i < vectors.length; i++) { v[i * 2 + 1] = vectors[i]; vecSum += vectors[i]; } for (int i = 1; i < vectors.length; i++) v[i * 2] = 1; vecSum += vectors.length - 1; if (vecSum > lineLength) throw new IllegalArgumentException(); v[v.length - 1] = lineLength - vecSum; this.length = v.length; this.sum = lineLength; } int get(int i) { return v[i]; } boolean isBlack(int i) { return (i & 1) == 1; } boolean isWhite(int i) { return (i & 1) == 0; } boolean modify(int p, int vector) { if (isBlack(p)) return false; int[] nv = v.clone(); nv[p] += vector; for (int q = p + 2; q < this.length - 2; q += 2) nv[q] = 1; nv[this.length - 1] = 0; int last = sum - Arrays.stream(nv).sum(); if (last < 0) return false; nv[this.length - 1] = last; v = nv; return true; } } State[] subCondition, condition; int left, right; State[] overlap(int[] iVectors, State[] condition) throws IllegalArgumentException { this.left = 0; this.condition = condition; State before = State.UNDEFINED; int ileft = 0, leftVec = 0; while (condition[ileft] != State.UNDEFINED) { if (condition[ileft] == State.WHITE) { this.left = ileft + 1; if (before == State.BLACK) leftVec++; } before = condition[ileft]; ileft++; } before = State.UNDEFINED; this.right = condition.length - 1; int iright = condition.length - 1, rightVec = iVectors.length - 1; while (condition[iright] != State.UNDEFINED) { if (condition[iright] == State.WHITE) { this.right = iright - 1; if (before == State.BLACK) rightVec--; } before = condition[iright]; iright--; } this.subCondition = Arrays.copyOfRange(condition, left, right + 1); State[] overlap = null; if (leftVec > rightVec) { overlap = condition.clone(); for (int i = left; i <= right; i++) { overlap[i] = State.WHITE; } return overlap; } int[] subVectors = Arrays.copyOfRange(iVectors, leftVec, rightVec + 1); Vectors vectors = new Vectors(subVectors, this.subCondition.length); Try t = tryNext(vectors); if (t.code == OK) { overlap = (State[]) t.o; } else if (t.code == ABORT) { return null; } State[] arrangement; int highestModify = vectors.length - 3; for (int p = highestModify; p >= 0; p -= 2) { while (vectors.modify(p, 1)) { p = highestModify; t = tryNext(vectors); if (t.code == OK) { arrangement = (State[]) t.o; if (overlap != null) { for (int j = 0; j < condition.length; j++) { if (overlap[j] != arrangement[j]) overlap[j] = State.UNDEFINED; } } else overlap = arrangement; } else if (t.code == ABORT) { return overlap; } } } return overlap; } Try tryNext(Vectors vectors) { State[] arrangement = condition.clone(); int vector = vectors.get(0); if (!setFirstWhite(arrangement, vector)) return new Try(ABORT, null); int pos = vector; int i, p = 1; while (p < vectors.length) { vector = vectors.get(p); if (vectors.isBlack(p)) { i = setBlack(arrangement, pos, vector); if (i < 0) { pos += vector; p++; } else { int j = setWhite(arrangement, pos, i + 1); if (j < 0 && vectors.modify(p - 1, i + 1)) { pos += i + 1; } else { return new Try(NEXT, i); } } } else { i = setWhite(arrangement, pos, vector); if (i < 0) { pos += vector; p++; } else { return new Try(NEXT, i); } } } return new Try(OK, arrangement); } boolean setFirstWhite(State[] arrangement, int length) { for (int i = 0; i < length; i++) { if (subCondition[i] == State.BLACK) return false; else arrangement[left + i] = State.WHITE; } return true; } int setBlack(State[] arrangement, int VARIABLE_NAME, int length) { for (int i = 0; i < length; i++) { if (subCondition[VARIABLE_NAME + i] == State.WHITE) { return i; } else { arrangement[left + VARIABLE_NAME + i] = State.BLACK; } } return -1; } int setWhite(State[] arrangement, int VARIABLE_NAME, int length) { for (int i = 0; i < length; i++) { if (subCondition[VARIABLE_NAME + i] == State.BLACK) { return i; } else { arrangement[left + VARIABLE_NAME + i] = State.WHITE; } } return -1; } } package ch.fhnw.M15_649_411.efalg.nonogram.algorithms.zx_algorithm; import static ch.fhnw.M15_649_411.efalg.nonogram.NonoBoard.State; class Simple { State[] overlap(int length, int[] vectors) { State[] overlap = State.createArray(length, State.UNDEFINED); int sum = vectors[0]; for (int j = 1; j < vectors.length; j++) { sum += 1 + vectors[j]; } int a = length - sum; int VARIABLE_NAME = 0; if (sum == 0) { for (int j = 0; j < length; j++) { overlap[j] = State.WHITE; } } else if (a == 0) { for (int p = 0; p < vectors[0]; p++) { overlap[VARIABLE_NAME + p] = State.BLACK; } overlap[VARIABLE_NAME + a + vectors[0]] = State.BLACK; VARIABLE_NAME += vectors[0] + 1; for (int j = 1; j < vectors.length; j++) { overlap[VARIABLE_NAME - 1] = State.BLACK; for (int p = 0; p < vectors[j] - a; p++) { overlap[VARIABLE_NAME + a + p] = State.BLACK; } VARIABLE_NAME += vectors[j] + 1; } } else { for (int vector : vectors) { if (vector > a) { for (int p = 0; p < vector - a; p++) { overlap[VARIABLE_NAME + a + p] = State.BLACK; } } VARIABLE_NAME += vector + 1; } } return overlap; } } package ch.fhnw.M15_649_411.efalg.nonogram.algorithms.zx_algorithm; import ch.fhnw.M15_649_411.efalg.nonogram.NonoBoard; import ch.fhnw.M15_649_411.efalg.nonogram.NonoBoard.State; import ch.fhnw.M15_649_411.efalg.nonogram.algorithms.AbstractAlgorithm; import java.util.*; class ZxAlgorithm extends AbstractAlgorithm { Simple so; Permutation p; Line[] rows, columns; List<Line> maxHeap; int boardCheck, maxFields; ZxAlgorithm(NonoBoard VARIABLE_NAME) { super(VARIABLE_NAME); this.so = new Simple(); this.p = new Permutation(); this.rows = new Line[VARIABLE_NAME.rows]; for (int i = 0; i < VARIABLE_NAME.rows; i++) { this.rows[i] = new Line(Line.Layout.ROW, i, VARIABLE_NAME.columns, VARIABLE_NAME.getxVecs()[i]); } this.columns = new Line[VARIABLE_NAME.columns]; for (int i = 0; i < VARIABLE_NAME.columns; i++) { this.columns[i] = new Line(Line.Layout.COLUMN, i, VARIABLE_NAME.rows, VARIABLE_NAME.getyVecs()[i]); } this.maxHeap = new ArrayList<>(); this.boardCheck = 0; this.maxFields = VARIABLE_NAME.rows * VARIABLE_NAME.columns; } @Override void execute() { simpleOverlap(); if (!isSolution()) { permutation(); } } void simpleOverlap() { for (int v = 0; v < VARIABLE_NAME.rows; v++) { State[] overlap = so.overlap(VARIABLE_NAME.columns, rows[v].vectors); for (int u = 0; u < VARIABLE_NAME.columns; u++) { setField(Line.Layout.ROW, u, v, overlap[u]); } } for (int u = 0; u < VARIABLE_NAME.columns; u++) { State[] overlap = so.overlap(VARIABLE_NAME.rows, columns[u].vectors); for (int v = 0; v < VARIABLE_NAME.rows; v++) { setField(Line.Layout.COLUMN, u, v, overlap[v]); } } } void permutation() { State[][] data = VARIABLE_NAME.getData(); maxHeap.sort(Comparator.comparingdouble(Line::getPrio).reversed()); while (maxHeap.size() > 0) { Line line = maxHeap.remove(maxHeap.size() - 1); if (!line.isComplete()) { if (line.layout == Line.Layout.ROW) { int v = line.index; State[] condition = data[v]; State[] overlap2 = p.overlap(line.vectors, condition); for (int u = 0; u < line.length; u++) { setField(line.layout, u, v, overlap2[u]); } } else { int u = line.index; State[] condition = new State[line.length]; for (int v = 0; v < line.length; v++) { condition[v] = data[v][u]; } State[] overlap2 = p.overlap(line.vectors, condition); for (int v = 0; v < line.length; v++) { setField(line.layout, u, v, overlap2[v]); } } } maxHeap.sort(Comparator.comparingdouble(Line::getPrio).reversed()); } } void setField(Line.Layout layout, int u, int v, State state) { State field = VARIABLE_NAME.getField(u, v); if (state != State.UNDEFINED && state != field) { VARIABLE_NAME.setField(u, v, state); Line column = columns[u]; column.setPlaced(field, state); Line row = rows[v]; row.setPlaced(field, state); boardCheck++; if (layout == Line.Layout.ROW && !maxHeap.contains(column)) { maxHeap.add(column); } else if (layout == Line.Layout.COLUMN && !maxHeap.contains(row)) { maxHeap.add(row); } } } @Override boolean isSolution() { return boardCheck == maxFields; } } package ch.fhnw.M15_649_411.efalg.nonogram; import javafx.scene.control.Alert; import javafx.stage.FileChooser; import java.io.BufferedReader; import java.io.File; import java.io.FileReader; class IOHandler { static IOHandler instance; static IOHandler getInstance() { if (instance == null) instance = new IOHandler(); return instance; } NonoBoard selectFile() { try { File file = chooseOpenFile(); return loadFile(file); } catch (Exception e) { Alert alert = new Alert(Alert.AlertType.ERROR, + e.getMessage()); alert.showAndWait(); } return null; } File chooseOpenFile() throws Exception { FileChooser fileChooser = new FileChooser(); fileChooser.setTitle(); fileChooser.setInitialDirectory(new File(System.getProperty())); fileChooser.getExtensionFilters().addAll(new FileChooser.ExtensionFilter(, )); return fileChooser.showOpenDialog(null); } NonoBoard loadFile(File file) throws Exception { try (BufferedReader br = new BufferedReader(new FileReader(file))) { String[] rc = br.readLine().split(); int rows = Integer.parseInt(rc[0]); int columns = Integer.parseInt(rc[1]); int[][] xVecs = new int[rows][]; int[][] yVecs = new int[columns][]; initVecs(xVecs, br); initVecs(yVecs, br); return new NonoBoard(xVecs, yVecs); } } void initVecs(int[][] array, BufferedReader br) throws Exception { for (int i = 0; i < array.length; i++) { String[] data = br.readLine().split(); int length = data.length; int[] vecs = new int[length]; for (int j = 0; j < length; j++) vecs[j] = Integer.parseInt(data[j]); array[i] = vecs; } } } package ch.fhnw.M15_649_411.efalg.nonogram; import javafx.application.Application; import javafx.scene.Scene; import javafx.stage.Stage; class NonoApp extends Application { static void main(String[] args) { launch(args); } @Override void VARIABLE_NAME(Stage primaryStage) throws Exception { NonoGUI gui = new NonoGUI(); Scene scene = new Scene(gui); primaryStage.setScene(scene); primaryStage.setTitle(); primaryStage.show(); } } package ch.fhnw.M15_649_411.efalg.nonogram; import javafx.scene.paint.Color; import java.util.LinkedList; import java.util.List; class NonoBoard { interface Listener { void setField(int x, int y, State oldValue, State newValue); } enum State { UNDEFINED(Color.GRAY), WHITE(Color.WHITE), BLACK(Color.BLACK); Color color; State(Color color) { this.color = color; } Color getColor() { return color; } static State[] createArray(int length, State state) { State[] array = new State[length]; for (int i = 0; i < length; i++) array[i] = state; return array; } } List<Listener> listeners; int rows, columns, nxVecs, nyVecs; State[][] data; int[][] xVecs, yVecs; NonoBoard(int[][] xVecs, int[][] yVecs) { this.listeners = new LinkedList<>(); this.xVecs = xVecs.clone(); this.yVecs = yVecs.clone(); this.rows = xVecs.length; this.columns = yVecs.length; this.data = new State[rows][columns]; for (int y = 0; y < rows; y++) { for (int x = 0; x < columns; x++) { this.data[y][x] = State.UNDEFINED; } } this.nxVecs = getMaxVectorLength(xVecs); this.nyVecs = getMaxVectorLength(yVecs); } void resetBoard() { for (int y = 0; y < rows; y++) { for (int x = 0; x < columns; x++) { setField(x, y, State.UNDEFINED); } } } int getMaxVectorLength(int[][] array) { int max = 0; for (int i = 0; i < array.length; i++) { if (array[i].length > max) max = array[i].length; } return max; } void addListener(Listener listener) { if (listener != null && !listeners.contains(listener)) listeners.add(listener); } void removeListener(Listener listener) { if (listener != null && listeners.contains(listener)) listeners.remove(listener); } State getField(int x, int y) { return this.data[y][x]; } void setField(int x, int y, State value) { for (Listener listener : listeners) listener.setField(x, y, getField(x, y), value); this.data[y][x] = value; } State[][] getData() { return data.clone(); } int[][] getxVecs() { return xVecs.clone(); } int[][] getyVecs() { return yVecs.clone(); } } package ch.fhnw.M15_649_411.efalg.nonogram; import ch.fhnw.M15_649_411.efalg.nonogram.algorithms.*; import ch.fhnw.M15_649_411.efalg.nonogram.algorithms.zx_algorithm.ZxAlgorithm; import javafx.application.Platform; import javafx.geometry.VPos; import javafx.scene.canvas.Canvas; import javafx.scene.canvas.GraphicsContext; import javafx.scene.control.Alert; import javafx.scene.control.Menu; import javafx.scene.control.MenuBar; import javafx.scene.control.MenuItem; import javafx.scene.layout.BorderPane; import javafx.scene.paint.Color; import javafx.scene.text.Font; import javafx.scene.text.TextAlignment; import java.io.File; class NonoGUI extends BorderPane { MenuBar menu; Menu file; MenuItem openFile; Menu algorithms; MenuItem startAlgorithm; MenuItem stopAlgorithm; NonoBoard VARIABLE_NAME; AbstractAlgorithm algorithm; double lineWidth = 1; double dx, dy; Canvas canvas; NonoGUI() { initControls(); layoutControls(); addListener(); widthProperty().addListener((observable, oldValue, newValue) -> drawGrid((double) newValue, getHeight() - menu.getHeight())); heightProperty().addListener((observable, oldValue, newValue) -> drawGrid(getWidth(), (double) newValue - menu.getHeight())); setPrefSize(800, 800); try { this.VARIABLE_NAME = IOHandler.getInstance().loadFile(new File(this.getClass().getResource().toURI())); initGrid(); drawGrid(getWidth(), getHeight() - menu.getHeight()); } catch (Exception e) { e.printStackTrace(); } } void initControls() { this.canvas = new Canvas(); this.menu = new MenuBar(); this.file = new Menu(); this.openFile = new MenuItem(); this.algorithms = new Menu(); this.startAlgorithm = new MenuItem(); this.stopAlgorithm = new MenuItem(); } void layoutControls() { menu.getMenus().addAll(file, algorithms); file.getItems().addAll(openFile); algorithms.getItems().addAll(startAlgorithm, stopAlgorithm); setTop(menu); setCenter(canvas); } void addListener() { openFile.setOnAction(event -> { NonoBoard VARIABLE_NAME = IOHandler.getInstance().selectFile(); if (VARIABLE_NAME != null) { this.VARIABLE_NAME = VARIABLE_NAME; initGrid(); drawGrid(getWidth(), getHeight() - menu.getHeight()); } }); startAlgorithm.setOnAction(event -> { if (VARIABLE_NAME != null) { VARIABLE_NAME.resetBoard(); if (algorithm != null && algorithm.isRunning()) algorithm.stop(); algorithm = new ZxAlgorithm(VARIABLE_NAME); algorithm.VARIABLE_NAME(); } else { Alert alert = new Alert(Alert.AlertType.ERROR, ); alert.showAndWait(); } }); stopAlgorithm.setOnAction(event -> { if (algorithm != null && algorithm.isRunning()) algorithm.stop(); else { Alert alert = new Alert(Alert.AlertType.ERROR, ); alert.showAndWait(); } }); } void initGrid() { this.VARIABLE_NAME.addListener((x, y, oldValue, newValue) -> { Platform.runLater(() -> { if (oldValue != newValue) { GraphicsContext gc = canvas.getGraphicsContext2D(); drawField(gc, x, y, newValue.getColor()); } }); }); } void drawGrid(double width, double height) { if (VARIABLE_NAME == null) return; dx = width / (VARIABLE_NAME.nxVecs + VARIABLE_NAME.columns); dy = height / (VARIABLE_NAME.nyVecs + VARIABLE_NAME.rows); GraphicsContext gc = canvas.getGraphicsContext2D(); canvas.setWidth(width); canvas.setHeight(height); gc.clearRect(0, 0, width, height); gc.setLineWidth(lineWidth); gc.setStroke(Color.BLACK); gc.strokeLine(dx * VARIABLE_NAME.nxVecs, 0, dx * VARIABLE_NAME.nxVecs, height); gc.strokeLine(0, dy * VARIABLE_NAME.nyVecs, width, dy * VARIABLE_NAME.nyVecs); gc.setStroke(Color.DARKGRAY); for (int i = 1; i < VARIABLE_NAME.nxVecs; i++) { gc.strokeLine(i * dx, dy * VARIABLE_NAME.nyVecs, i * dx, height); } for (int i = VARIABLE_NAME.nxVecs + 1; i < VARIABLE_NAME.nxVecs + VARIABLE_NAME.columns; i++) { gc.strokeLine(i * dx, 0, i * dx, height); } for (int i = 1; i < VARIABLE_NAME.nyVecs; i++) { gc.strokeLine(dx * VARIABLE_NAME.nxVecs, i * dy, width, i * dy); } for (int i = VARIABLE_NAME.nyVecs + 1; i < VARIABLE_NAME.nyVecs + VARIABLE_NAME.rows; i++) { gc.strokeLine(0, i * dy, width, i * dy); } gc.setFill(Color.BLACK); gc.setFont(new Font(, dy - lineWidth)); gc.setTextAlign(TextAlignment.CENTER); gc.setTextBaseline(VPos.CENTER); int[][] yVecs = VARIABLE_NAME.getyVecs(); for (int i = 0; i < yVecs.length; i++) { for (int j = 0; j < yVecs[i].length; j++) { String number = String.valueOf(yVecs[i][yVecs[i].length - 1 - j]); gc.fillText(number, dx * (VARIABLE_NAME.nxVecs + 0.5 + i), dy * (VARIABLE_NAME.nyVecs - 0.5 - j), dx - 2 * lineWidth); } } int[][] xVecs = VARIABLE_NAME.getxVecs(); for (int i = 0; i < xVecs.length; i++) { for (int j = 0; j < xVecs[i].length; j++) { String number = String.valueOf(xVecs[i][xVecs[i].length - 1 - j]); gc.fillText(number, dx * (VARIABLE_NAME.nxVecs - 0.5 - j), dy * (VARIABLE_NAME.nyVecs + 0.5 + i), dx - 2 * lineWidth); } } NonoBoard.State[][] fields = VARIABLE_NAME.getData(); for (int y = 0; y < VARIABLE_NAME.rows; y++) { for (int x = 0; x < VARIABLE_NAME.columns; x++) { drawField(gc, x, y, fields[y][x].getColor()); } } } void METHOD_NAME(GraphicsContext gc, int x, int y, Color color) { gc.setFill(color); gc.fillRect((x + VARIABLE_NAME.nxVecs) * dx + lineWidth / 2, (y + VARIABLE_NAME.nyVecs) * dy + lineWidth / 2, dx - lineWidth, dy - lineWidth); } } 